{"ast":null,"code":"export const isAdjacent = (cell1, cell2, gridCols) => {\n  if (!cell1 || !cell2) return false;\n  const rowDiff = Math.abs(cell1.row - cell2.row);\n  const colDiff = Math.abs(cell1.col - cell2.col);\n\n  // Adjacent horizontally, vertically, or diagonally\n  if (rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0)) {\n    return true;\n  }\n\n  // Check wrap-around: end of one line to beginning of next line\n  if (cell1.col === gridCols - 1 && cell2.col === 0 && cell2.row === cell1.row + 1) {\n    return true;\n  }\n  return false;\n};\nexport const hasValidPath = (cell1, cell2, matchedCells, visibleRows, gridCols) => {\n  if (!cell1 || !cell2) return false;\n\n  // Check if cells are directly adjacent (including diagonal and wrap-around)\n  if (isAdjacent(cell1, cell2, gridCols)) {\n    return true;\n  }\n\n  // BFS to find path through matched (empty) cells\n  const queue = [[cell1.row, cell1.col, []]];\n  const visited = new Set([`${cell1.row}-${cell1.col}`]);\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0],\n  // horizontal and vertical\n  [1, 1], [1, -1], [-1, 1], [-1, -1] // diagonals\n  ];\n  while (queue.length > 0) {\n    const [currentRow, currentCol, path] = queue.shift();\n\n    // Check all directions\n    for (const [dx, dy] of directions) {\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      const newKey = `${newRow}-${newCol}`;\n\n      // Check boundaries\n      if (newRow < 0 || newRow >= visibleRows || newCol < 0 || newCol >= gridCols) {\n        continue;\n      }\n\n      // Skip if already visited\n      if (visited.has(newKey)) continue;\n\n      // Check if we reached the target through matched cells\n      if (newRow === cell2.row && newCol === cell2.col) {\n        // All cells in path must be matched\n        if (path.every(key => matchedCells.has(key))) {\n          return true;\n        }\n      }\n\n      // Can only move through matched cells\n      if (matchedCells.has(newKey)) {\n        visited.add(newKey);\n        queue.push([newRow, newCol, [...path, newKey]]);\n      }\n    }\n  }\n  return false;\n};\nexport const canMatch = (val1, val2) => {\n  return val1 === val2 || val1 + val2 === 10;\n};","map":{"version":3,"names":["isAdjacent","cell1","cell2","gridCols","rowDiff","Math","abs","row","colDiff","col","hasValidPath","matchedCells","visibleRows","queue","visited","Set","directions","length","currentRow","currentCol","path","shift","dx","dy","newRow","newCol","newKey","has","every","key","add","push","canMatch","val1","val2"],"sources":["C:/Users/varun s/Desktop/project/number-puzzle-game/src/utils/pathValidator.js"],"sourcesContent":["export const isAdjacent = (cell1, cell2, gridCols) => {\r\n  if (!cell1 || !cell2) return false;\r\n  const rowDiff = Math.abs(cell1.row - cell2.row);\r\n  const colDiff = Math.abs(cell1.col - cell2.col);\r\n  \r\n  // Adjacent horizontally, vertically, or diagonally\r\n  if (rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0)) {\r\n    return true;\r\n  }\r\n  \r\n  // Check wrap-around: end of one line to beginning of next line\r\n  if (cell1.col === gridCols - 1 && cell2.col === 0 && cell2.row === cell1.row + 1) {\r\n    return true;\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\nexport const hasValidPath = (cell1, cell2, matchedCells, visibleRows, gridCols) => {\r\n  if (!cell1 || !cell2) return false;\r\n  \r\n  // Check if cells are directly adjacent (including diagonal and wrap-around)\r\n  if (isAdjacent(cell1, cell2, gridCols)) {\r\n    return true;\r\n  }\r\n  \r\n  // BFS to find path through matched (empty) cells\r\n  const queue = [[cell1.row, cell1.col, []]];\r\n  const visited = new Set([`${cell1.row}-${cell1.col}`]);\r\n  const directions = [\r\n    [0, 1], [1, 0], [0, -1], [-1, 0],  // horizontal and vertical\r\n    [1, 1], [1, -1], [-1, 1], [-1, -1] // diagonals\r\n  ];\r\n  \r\n  while (queue.length > 0) {\r\n    const [currentRow, currentCol, path] = queue.shift();\r\n    \r\n    // Check all directions\r\n    for (const [dx, dy] of directions) {\r\n      const newRow = currentRow + dx;\r\n      const newCol = currentCol + dy;\r\n      const newKey = `${newRow}-${newCol}`;\r\n      \r\n      // Check boundaries\r\n      if (newRow < 0 || newRow >= visibleRows || newCol < 0 || newCol >= gridCols) {\r\n        continue;\r\n      }\r\n      \r\n      // Skip if already visited\r\n      if (visited.has(newKey)) continue;\r\n      \r\n      // Check if we reached the target through matched cells\r\n      if (newRow === cell2.row && newCol === cell2.col) {\r\n        // All cells in path must be matched\r\n        if (path.every(key => matchedCells.has(key))) {\r\n          return true;\r\n        }\r\n      }\r\n      \r\n      // Can only move through matched cells\r\n      if (matchedCells.has(newKey)) {\r\n        visited.add(newKey);\r\n        queue.push([newRow, newCol, [...path, newKey]]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  return false;\r\n};\r\n\r\nexport const canMatch = (val1, val2) => {\r\n  return val1 === val2 || val1 + val2 === 10;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}